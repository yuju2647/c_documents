/* ======================================== */
/*    程序实例: 4-1.c                       */
/*    使用数组来构建栈实现洗牌               */
/* ======================================== */
#include <stdio.h>	
#include <time.h>
#include <stdlib.h>
#define MAXSIZE  100				/*定义MaxSize为100*/
typedef int DataType;					/*定义DataType为int*/
typedef struct
{
	DataType stack[MAXSIZE];
	int top;
}SeqStack;

/* ---------------------------------------------------------------- */
/*  初始化顺序                               */
/* ---------------------------------------------------------------- */
void StackInitiate(SeqStack *S)			/*初始化顺序堆栈S*/
{
	S->top=-1;						/*定义初始栈顶下标值*/	
}

/* ---------------------------------------------------------------- */
/*  判断栈空                                 */
/* ---------------------------------------------------------------- */
int StackNotEmpty(SeqStack S)  /*判顺序堆栈S是否为空，非空则返回1，否则返回0*/
{
	if(S.top<=-1)	return 0;
	else return 1;
}

/* ---------------------------------------------------------------- */
/*  入栈操作                                 */
/* ---------------------------------------------------------------- */
int StackPush(SeqStack *S, DataType x) 
	/*把数据元素值x压入顺序堆栈S，入栈成功则返回1，否则返回0 */
{
	if(S->top>=MAXSIZE)
	{
		printf("堆栈已满无法插入! \n");
		return 0;
	}
	else
	{   
		S->top++;
		S->stack[S->top]=x;		
		return 1;
	}
}

/* ---------------------------------------------------------------- */
/*  出栈操作                                  */
/* ---------------------------------------------------------------- */
int StackPop(SeqStack *S, DataType *d) 
	/*弹出顺序堆栈S的栈顶数据元素值到参数d ，出栈成功则返回1，否则返回0*/
{
	if(S->top<=-1)
	{
		printf("堆栈已空无数据元素出栈! \n");
		return 0;
	}
	else
	{
		*d = S->stack[S->top];
		S->top--;
		return 1;
	}
}

/* ---------------------------------------------------------- */
/*  主程序: 洗牌后, 将牌发给四个人.         */
/*     红心: 数组 0 - 12                   */
/*     方块: 数组 13 - 25                   */
/*     梅花: 数组 26 - 38                   */
/*     黑桃: 数组 39 - 51                   */
/* ---------------------------------------------------------- */
main()                   		/*主程序*/
{
	SeqStack stack;
	int i,temp;
	DataType y;
	DataType z;
	int card[52];                    /* 朴克牌数组         */
	int pos;                        /* 牌代码             */
	long temptime;
	StackInitiate(&stack);       	 /*建立空栈stack*/
	if(StackNotEmpty(stack)==0)     /*判断栈stack是否为空*/
		printf("\n栈为空!");
	else
		printf("\n栈非空!");

	srand(time(&temptime) % 60);     /* 使用时间初始化随机数  */
	for(i=0;i<52;i++ )
		card[i] = 0;                /* 清除扑克牌数组      */
	i = 0;
	while(i!= 52)                   /* 洗牌循环            */
	{
		pos = rand() % 52;          /* 随机数取值 0-51      */
		if ( card[pos] == 0 )         /* 是否是未洗牌       */
		{
			StackPush(&stack,pos);  /* 存此张牌进栈     */
			card[pos] = 1;          /* 设置此张牌洗过     */
			i++;                  /* 下一张牌           */
		}
	}

	printf("    1      2      3      4 \n");
	printf(" ==========================\n");
	for ( i = 0; i < 5; i++ )      /* 发牌给四人的循环   */
	{
		StackPop(&stack,&z);	   /* 取出栈数据   */
		printf(" [%c%2d] ",z / 13 + 3,z % 13 + 1);              // ①
		StackPop(&stack,&z);	   /* 取出栈数据   */
		printf(" [%c%2d] ",z / 13 + 3,z % 13 + 1);
		StackPop(&stack,&z);       /* 取出栈数据   */
		printf(" [%c%2d] ",z / 13 + 3,z % 13 + 1);
		StackPop(&stack,&z);       /* 取出栈数据   */
		printf(" [%c%2d] ",z / 13 + 3,z % 13 + 1);		
		printf("\n");
	}
}
//程序运行结果：

